// Code generated by MockGen. DO NOT EDIT.
// Source: repo.go
//
// Generated by this command:
//
//	mockgen -source=repo.go -mock_names=Repo=MockRepository -destination=../../mock/mock_repository.go -package=mock
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	repo "go-fiber-api/internal/core/repo"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockGormModel is a mock of GormModel interface.
type MockGormModel[D any] struct {
	ctrl     *gomock.Controller
	recorder *MockGormModelMockRecorder[D]
	isgomock struct{}
}

// MockGormModelMockRecorder is the mock recorder for MockGormModel.
type MockGormModelMockRecorder[D any] struct {
	mock *MockGormModel[D]
}

// NewMockGormModel creates a new mock instance.
func NewMockGormModel[D any](ctrl *gomock.Controller) *MockGormModel[D] {
	mock := &MockGormModel[D]{ctrl: ctrl}
	mock.recorder = &MockGormModelMockRecorder[D]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGormModel[D]) EXPECT() *MockGormModelMockRecorder[D] {
	return m.recorder
}

// FromDTO mocks base method.
func (m *MockGormModel[D]) FromDTO(dto D) any {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FromDTO", dto)
	ret0, _ := ret[0].(any)
	return ret0
}

// FromDTO indicates an expected call of FromDTO.
func (mr *MockGormModelMockRecorder[D]) FromDTO(dto any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FromDTO", reflect.TypeOf((*MockGormModel[D])(nil).FromDTO), dto)
}

// ToDTO mocks base method.
func (m *MockGormModel[D]) ToDTO() D {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ToDTO")
	ret0, _ := ret[0].(D)
	return ret0
}

// ToDTO indicates an expected call of ToDTO.
func (mr *MockGormModelMockRecorder[D]) ToDTO() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ToDTO", reflect.TypeOf((*MockGormModel[D])(nil).ToDTO))
}

// MockRepository is a mock of Repo interface.
type MockRepository[E repo.GormModel[D], D any] struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder[E, D]
	isgomock struct{}
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder[E repo.GormModel[D], D any] struct {
	mock *MockRepository[E, D]
}

// NewMockRepository creates a new mock instance.
func NewMockRepository[E repo.GormModel[D], D any](ctrl *gomock.Controller) *MockRepository[E, D] {
	mock := &MockRepository[E, D]{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder[E, D]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository[E, D]) EXPECT() *MockRepositoryMockRecorder[E, D] {
	return m.recorder
}

// Count mocks base method.
func (m *MockRepository[E, D]) Count(ctx context.Context, specifications ...repo.Specification) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range specifications {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Count", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockRepositoryMockRecorder[E, D]) Count(ctx any, specifications ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, specifications...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockRepository[E, D])(nil).Count), varargs...)
}

// Delete mocks base method.
func (m *MockRepository[E, D]) Delete(ctx context.Context, dto *D) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, dto)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockRepositoryMockRecorder[E, D]) Delete(ctx, dto any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockRepository[E, D])(nil).Delete), ctx, dto)
}

// DeleteById mocks base method.
func (m *MockRepository[E, D]) DeleteById(ctx context.Context, id any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteById", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteById indicates an expected call of DeleteById.
func (mr *MockRepositoryMockRecorder[E, D]) DeleteById(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteById", reflect.TypeOf((*MockRepository[E, D])(nil).DeleteById), ctx, id)
}

// Find mocks base method.
func (m *MockRepository[E, D]) Find(ctx context.Context, specifications ...repo.Specification) ([]D, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range specifications {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Find", varargs...)
	ret0, _ := ret[0].([]D)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Find indicates an expected call of Find.
func (mr *MockRepositoryMockRecorder[E, D]) Find(ctx any, specifications ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, specifications...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockRepository[E, D])(nil).Find), varargs...)
}

// FindAll mocks base method.
func (m *MockRepository[E, D]) FindAll(ctx context.Context) ([]D, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindAll", ctx)
	ret0, _ := ret[0].([]D)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindAll indicates an expected call of FindAll.
func (mr *MockRepositoryMockRecorder[E, D]) FindAll(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockRepository[E, D])(nil).FindAll), ctx)
}

// FindByID mocks base method.
func (m *MockRepository[E, D]) FindByID(ctx context.Context, id any) (D, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByID", ctx, id)
	ret0, _ := ret[0].(D)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByID indicates an expected call of FindByID.
func (mr *MockRepositoryMockRecorder[E, D]) FindByID(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockRepository[E, D])(nil).FindByID), ctx, id)
}

// FindWithLimit mocks base method.
func (m *MockRepository[E, D]) FindWithLimit(ctx context.Context, limit, offset int, specifications ...repo.Specification) ([]D, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, limit, offset}
	for _, a := range specifications {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindWithLimit", varargs...)
	ret0, _ := ret[0].([]D)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindWithLimit indicates an expected call of FindWithLimit.
func (mr *MockRepositoryMockRecorder[E, D]) FindWithLimit(ctx, limit, offset any, specifications ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, limit, offset}, specifications...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindWithLimit", reflect.TypeOf((*MockRepository[E, D])(nil).FindWithLimit), varargs...)
}

// FindWithPagination mocks base method.
func (m *MockRepository[E, D]) FindWithPagination(ctx context.Context, page, limit int, specifications ...repo.Specification) ([]D, repo.PaginationMetadata, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, page, limit}
	for _, a := range specifications {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindWithPagination", varargs...)
	ret0, _ := ret[0].([]D)
	ret1, _ := ret[1].(repo.PaginationMetadata)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FindWithPagination indicates an expected call of FindWithPagination.
func (mr *MockRepositoryMockRecorder[E, D]) FindWithPagination(ctx, page, limit any, specifications ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, page, limit}, specifications...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindWithPagination", reflect.TypeOf((*MockRepository[E, D])(nil).FindWithPagination), varargs...)
}

// Insert mocks base method.
func (m *MockRepository[E, D]) Insert(ctx context.Context, dto *D) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", ctx, dto)
	ret0, _ := ret[0].(error)
	return ret0
}

// Insert indicates an expected call of Insert.
func (mr *MockRepositoryMockRecorder[E, D]) Insert(ctx, dto any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockRepository[E, D])(nil).Insert), ctx, dto)
}

// Update mocks base method.
func (m *MockRepository[E, D]) Update(ctx context.Context, dto *D) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, dto)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockRepositoryMockRecorder[E, D]) Update(ctx, dto any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockRepository[E, D])(nil).Update), ctx, dto)
}
